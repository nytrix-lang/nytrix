#!/usr/bin/env python3
"""
Nytrix std bundler
"""
import os
import sys
from pathlib import Path
import re

def bundle_std():
    def file_priority(f):
        path_s = str(f)
        if "core/primitives.ny" in path_s: return 0
        if "os/sys.ny" in path_s: return 1
        if "str/mod.ny" in path_s: return 2
        if "str/io.ny" in path_s: return 3
        if "core/reflect.ny" in path_s: return 4
        if "core/error.ny" in path_s: return 5
        if "core/list.ny" in path_s: return 6
        if "core/dict.ny" in path_s: return 7
        if "core/set.ny" in path_s: return 8
        if "core/mod.ny" in path_s: return 9
        if f.name == "mod.ny": return 20
        return 30
    
    std_dir = Path("std")
    if not std_dir.exists():
        print("Error: std/ directory not found", file=sys.stderr)
        return 1
    files = list(std_dir.rglob("*.ny"))
    if not files:
        print("Warning: No .ny files in std/", file=sys.stderr)
        return 0
    sorted_files = sorted(list(set(files)), key=lambda f: (file_priority(f), str(f)))
    bundled_output_lines = []
    symbol_map = {}
    for f in sorted_files:
        content = f.read_text()
        rel_path = f.relative_to("std")
        parts = list(rel_path.parts)
        if parts[-1] == "mod.ny":
            parts.pop()
        else:
            parts[-1] = parts[-1].replace(".ny", "")
        full_mod_name = "std." + ".".join(parts)
        bundled_output_lines.append(f";; Module from {rel_path.as_posix().replace('.ny', '')}\n")
        bundled_output_lines.append(content)
        bundled_output_lines.append("\n")
        for line in content.split('\n'):
            stripped_line = line.strip()
            if line.startswith('fn '):
                name_part = line[3:].split('(')[0].strip()
                if not name_part.startswith('_'):
                    symbol_map[name_part] = full_mod_name
            elif line.startswith('def '):
                def_match = re.match(r'def\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*=', line)
                if def_match:
                    name_part = def_match.group(1).strip()
                    if not name_part.startswith('_'):
                        symbol_map[name_part] = full_mod_name
    if len(sys.argv) > 1:
        bundle_path = Path(sys.argv[1])
    else:
        bundle_path = Path("build/std_bundle.ny")
    bundle_path.parent.mkdir(exist_ok=True, parents=True)
    bundle_path.write_text('\n'.join(bundled_output_lines))
    sym_path = bundle_path.parent / "std_symbols.h"
    with sym_path.open('w') as h:
        h.write("#pragma once\n")
        h.write("typedef struct { const char *sym; const char *mod; } nt_std_symbol;\n")
        h.write("static const nt_std_symbol nt_std_symbols[] = {\n")
        for sym, mod in symbol_map.items():
            h.write(f'    {{"{sym}", "{mod}"}},\n')
        h.write("    {0, 0}\n")
        h.write("};\n")
    print(f"Bundled {len(files)} std modules -> {bundle_path}", file=sys.stderr)
    print(f"Generated {len(symbol_map)} symbols -> {sym_path}", file=sys.stderr)
    return 0

if __name__ == "__main__":
    sys.exit(bundle_std())