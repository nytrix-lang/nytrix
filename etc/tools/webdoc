#!/usr/bin/env python3
import os
import sys
import re
import json
import http.server
import socketserver
import argparse

script_dir = os.path.dirname(os.path.abspath(__file__))
template_path = os.path.join(script_dir, "assets", "webdoc.html")
if not os.path.exists(template_path):
    template_path = "webdoc.html"

try:
    with open(template_path, 'r') as f:
        HTML_TEMPLATE = f.read()
    
    js_path = os.path.join(script_dir, "assets", "webdoc.js")
    if os.path.exists(js_path):
        with open(js_path, 'r') as f:
            js_content = f.read()
            HTML_TEMPLATE = HTML_TEMPLATE.replace('SCRIPT_PLACEHOLDER', js_content)
except:
    HTML_TEMPLATE = "<html><body>Error: Template not found</body></html>"

def load_markdown_docs(docs_dir):
    docs = []
    if not os.path.exists(docs_dir):
        return docs
    for filename in sorted(os.listdir(docs_dir)):
        if filename.endswith(".md"):
            filepath = os.path.join(docs_dir, filename)
            name = filename[:-3] # Remove .md
            with open(filepath, 'r', encoding='utf-8') as f:
                md_content = f.read()
                docs.append({
                    "name": name,
                    "html": md_content # Send raw markdown to JS
                })
    return docs

def find_missing_docs(root_dir):
    missing_docs = []
    
    for dirpath, _, filenames in os.walk(root_dir):
        for filename in filenames:
            if not filename.endswith('.ny'):
                continue
            
            filepath = os.path.join(dirpath, filename)
            with open(filepath, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            i = 0
            while i < len(lines):
                line = lines[i].strip()
                # Simple check for function start
                if line.startswith('fn ') or line.startswith('pub fn '):
                    # extract name
                    parts = line.split('(')[0].split()
                    if not parts: 
                        i+=1
                        continue
                    func_name = parts[-1]
                    
                    # Ignore private functions
                    if func_name.startswith('_'):
                        i += 1
                        continue
                        
                    # Now check body for docstring.
                    has_doc = False
                    # Check current line after { if present
                    if '{' in line:
                        after_brace = line.split('{', 1)[1].strip()
                        if after_brace.startswith('"') or after_brace.startswith("'"):
                            has_doc = True
                    
                    if not has_doc:
                        # Check next few lines
                        for j in range(i + 1, min(i + 5, len(lines))):
                            next_line = lines[j].strip()
                            if not next_line: continue
                            if next_line.startswith('"') or next_line.startswith("'"):
                                has_doc = True
                            if next_line.startswith('def ') or next_line.startswith('if') or next_line.startswith('return') or next_line.startswith('while') or next_line.startswith('}'):
                                # Code started, stop looking
                                break
                            if has_doc: break
                            
                    if not has_doc:
                        missing_docs.append(f"{filepath}:{i+1} {func_name}")
                i += 1

    return missing_docs

def parse_nytrix_docs(bundle_path):
    if not os.path.exists(bundle_path): return []
    with open(bundle_path, 'r') as f: content = f.read()
    modules = []
    # Split by module header, capturing the delimiter to extract filename
    chunks = re.split(r'(;;\s*Module from\s+.*)', content)
    
    # Iterate over chunks, looking for header + body pairs
    i = 0
    while i < len(chunks):
        chunk = chunks[i]
        header = ""
        body = chunk
        
        # If this chunk is a header, the next one is the body
        if chunk.strip().startswith(';; Module from'):
            header = chunk
            if i + 1 < len(chunks):
                body = chunks[i+1]
                i += 1 # Skip body in next iteration
            else:
                body = ""
        elif not chunk.strip():
            i += 1
            continue
            
        # Parse module from body
        mod_match = re.search(r'module\s+([a-zA-Z0-9.]+)\s*\(', body)
        if not mod_match:
            i += 1
            continue
            
        mod_name = mod_match.group(1)
        
        # Derive path (list of components) from mod_name
        path = mod_name.split('.')

        # Extract original file path from header
        orig_file = ""
        if header:
            module_source_pattern = re.compile(r';;\s*Module from\s+([a-zA-Z0-9_/.]+)\.ny')
            module_source_match = module_source_pattern.search(header)
            orig_file = module_source_match.group(1) + '.ny' if module_source_match else ""

        # If it's a mod.ny file, ensure the mod_name ends with .mod 
        # to avoid repetition in sidebar and allow #std.cli.mod anchors
        if orig_file.endswith('mod.ny') and not mod_name.endswith('.mod'):
            mod_name += ".mod"
            path = mod_name.split('.')
        
        mod_doc = ""
        lines = body.splitlines()
        for line in lines:
            if line.strip().startswith(';;') and 'Keywords:' not in line and 'Module from' not in line:
                mod_doc += line.replace(';;', '').strip() + "\n"
            elif 'module' in line: break
        
        # Use body for symbol parsing
        chunk = body 
        symbols = []
        i += 1
        def sanitize_id(name):
            return re.sub(r'[^a-zA-Z0-9_]', '_', name)

        fn_start_pattern = re.compile(r'fn\s+([a-zA-Z0-9_.:]+)\s*\((.*?)\)\s*\{', re.DOTALL) # Updated to allow qualified names
        # Updated doc_pattern to match a string literal at the beginning of the function body
        doc_pattern = re.compile(r'\s*("((?:[^"\\]|\\.)*)"|\'((?:[^\'\\]|\\.)*)\')', re.DOTALL)
        curr_pos = 0
        while True:
            m = fn_start_pattern.search(chunk, curr_pos)
            if not m: break
            name, args = m.groups() # name is now "std.os.thread::mutex_free"
            
            full_name = name # No need to prepend mod_name anymore, as name is already qualified
            if args.strip():
                full_name += f"({args.strip()})" # Add arguments to the name if present
            
            # Robust parser for function body
            start_bracket = m.end() - 1
            body = ""
            depth = 0
            
            # State constants
            STATE_NORMAL = 0
            STATE_STRING_DQ = 1 # "
            STATE_STRING_SQ = 2 # '
            STATE_COMMENT = 3   # ;
            
            state = STATE_NORMAL
            
            k = start_bracket
            while k < len(chunk):
                char = chunk[k]
                
                if state == STATE_NORMAL:
                    if char == '"':
                        state = STATE_STRING_DQ
                    elif char == "'":
                        state = STATE_STRING_SQ
                    elif char == ';':
                        state = STATE_COMMENT
                    elif char == '{':
                        depth += 1
                    elif char == '}':
                        depth -= 1
                        if depth == 0:
                            body = chunk[start_bracket:k+1]
                            curr_pos = k + 1
                            found_body = True
                            break
                            
                elif state == STATE_STRING_DQ:
                    if char == '"':
                        # Check for escape
                        backslashes = 0
                        idx = k - 1
                        while idx >= 0 and chunk[idx] == '\\':
                            backslashes += 1
                            idx -= 1
                        if backslashes % 2 == 0:
                            state = STATE_NORMAL
                            
                elif state == STATE_STRING_SQ:
                    if char == "'":
                         # Check for escape
                        backslashes = 0
                        idx = k - 1
                        while idx >= 0 and chunk[idx] == '\\':
                            backslashes += 1
                            idx -= 1
                        if backslashes % 2 == 0:
                            state = STATE_NORMAL
                            
                elif state == STATE_COMMENT:
                    if char == '\n':
                        state = STATE_NORMAL
                
                k += 1
            
            if not found_body:
                 # Safeguard: if we didn't find the end of the function, skip past the start to avoid infinite loop
                 curr_pos = m.end()
                 continue

            doc_match = doc_pattern.search(body) # Define doc_match here
            if doc_match:
                # Updated doc assignment to use group 2 or 3 for the string content
                doc = (doc_match.group(2) or doc_match.group(3) or "").strip()
                code_view = body.replace(doc_match.group(0), '', 1).strip()
            else:
                doc = "" # Default doc to empty string if no match
                code_view = body
            
            # Robust line-based stripping to preserve indentation
            lines = code_view.splitlines()
            if len(lines) > 1:
                idx_start = 1
                while idx_start < len(lines)-1 and not lines[idx_start].strip(): idx_start += 1
                idx_end = len(lines) - 2
                while idx_end >= idx_start and not lines[idx_end].strip(): idx_end -= 1
                if idx_start <= idx_end:
                    code_view = lines[0] + "\n" + "\n".join(lines[idx_start:idx_end+1]) + "\n" + lines[-1]
                else:
                    code_view = lines[0] + "\n" + lines[-1]
            
            # Extract imports from the function body
            imports = []
            import_pattern = re.compile(r'use\s+([a-zA-Z0-9_.]+)(?:\s+as\s+([a-zA-Z0-9_]+))?')
            for m_import in import_pattern.finditer(body):
                full_import_path = m_import.group(1)
                alias = m_import.group(2)
                
                path_components = full_import_path.split('.')
                symbol_name = path_components[-1]
                module_target_path = ".".join(path_components[:-1]) if len(path_components) > 1 else ""

                imports.append({
                    'full_path': full_import_path,
                    'alias': alias,
                    'module_target': module_target_path,
                    'symbol_target': symbol_name
                })

            symbols.append({"id": sanitize_id(full_name), "name": full_name, "kind": "function", "doc": doc, "code": code_view.strip(), "imports": imports})
        def_pattern = re.compile(r'def\s+define\s+([a-zA-Z0-9_]+)\s*=', re.MULTILINE) # Exclude commented definitions
        for m in def_pattern.finditer(chunk):
            name = m.group(1)
            symbols.append({"id": sanitize_id(name), "name": name, "kind": "constant", "sig": f"def {name}", "doc": "Constant definition.", "code": m.group(0).strip()})
        modules.append({"name": mod_name, "module_doc": mod_doc.strip(), "symbols": symbols, "path": path})
    
    markdown_docs = load_markdown_docs(os.path.join(script_dir, "..", "..", "docs")) # root/docs is relative to etc/tools/webdoc
    
    overview_module = {
        "name": "Overview",
        "module_doc": "Welcome to the Nytrix Standard Library Documentation.",
        "symbols": [],
        "categories_data": {},
        "path": ["Home"],
        "markdown_docs": markdown_docs
    }
    
    modules.insert(0, overview_module)
    return modules

def main():
    parser = argparse.ArgumentParser(description='Nytrix Web Doc Generator')
    parser.add_argument('input', help='Input bundle file (e.g. build/std_bundle.ny)')
    parser.add_argument('--output', '-o', default='build/docs/index.html', help='Output HTML file')
    parser.add_argument('--serve', '-s', action='store_true', help='Serve the generated docs')
    parser.add_argument('--port', '-p', type=int, default=8000, help='Port for server')
    parser.add_argument('--check-docs', action='store_true', help='Check for missing docstrings')
    args = parser.parse_args()
    
    if args.check_docs:
        print("Checking for missing docstrings...")
        # Assume std is in current working directory or relative to script's typical location
        # But script is in etc/tools/webdoc
        # Maybe use a default std path or another arg
        # We can try to guess or use CWD if it looks like the root
        std_dir = "std"
        if os.path.exists(std_dir):
            missing = find_missing_docs(std_dir)
            if missing:
                for item in missing:
                    print(f"MISSING: {item}")
            else:
                print("All public functions have docstrings!")
        else:
            print("Error: 'std' directory not found in current path.")
        if not args.input: # Allow running just for check if input is optional or handled
             return

    if not os.path.exists(args.input): sys.exit(1)
    doc_data = parse_nytrix_docs(args.input)
    html = HTML_TEMPLATE.replace('DATA_PLACEHOLDER', json.dumps(doc_data))
    if os.path.dirname(args.output): os.makedirs(os.path.dirname(args.output), exist_ok=True)
    with open(args.output, 'w') as f: f.write(html)
    if args.serve:
        target_dir = os.path.abspath(os.path.dirname(args.output))
        os.chdir(target_dir)
        handler = http.server.SimpleHTTPRequestHandler
        socketserver.TCPServer.allow_reuse_address = True
        with socketserver.TCPServer(("", args.port), handler) as httpd:
            try: httpd.serve_forever()
            except KeyboardInterrupt: httpd.server_close()

if __name__ == "__main__":
    main()
