#!/usr/bin/env python3
"""
Nytrix Document Generator
"""
import os, sys, re, json, argparse, socketserver
from pathlib import Path
from http.server import SimpleHTTPRequestHandler, HTTPServer

script_dir = os.path.dirname(os.path.abspath(__file__))
template_path = os.path.join(script_dir, "..", "assets", "web", "webdoc.html")
if not os.path.exists(template_path):
    template_path = "webdoc.html"

try:
    with open(template_path, "r") as f:
        HTML_TEMPLATE = f.read()
    js_path = os.path.join(script_dir, "..", "assets", "web", "webdoc.js")
    if os.path.exists(js_path):
        with open(js_path, "r") as f:
            JS_SCRIPT_TEMPLATE = f.read()
    else:
        print(f"Error: webdoc.js not found at {js_path}", file=sys.stderr)
        sys.exit(1)
except FileNotFoundError as e:
    print(f"Error: {e}. Make sure assets folder exists.", file=sys.stderr)
    sys.exit(1)

def _extract_body_html(html_text):
    body_match = re.search(r"<body[^>]*>(.*?)</body>", html_text, re.DOTALL | re.IGNORECASE)
    if body_match:
        return body_match.group(1)
    return html_text

def _refine_info_html(html_text):
    html_text = html_text.replace(
        '<div class="contents" style="margin-left: 20px;">',
        '<div class="contents">'
    )
    html_text = html_text.replace(
        '<ul class="mini-toc" style="margin-left: 20px;">',
        '<ul class="mini-toc">'
    )
    html_text = re.sub(r'<div class="nav-panel">.*?</div>', '', html_text, flags=re.DOTALL | re.IGNORECASE)
    html_text = re.sub(r'Next:\s.*?(\s|&nbsp;|</p>|<br>)', '', html_text, flags=re.IGNORECASE)
    html_text = re.sub(r'Previous:\s.*?(\s|&nbsp;|</p>|<br>)', '', html_text, flags=re.IGNORECASE)
    html_text = re.sub(r'Up:\s.*?(\s|&nbsp;|</p>|<br>)', '', html_text, flags=re.IGNORECASE)
    html_text = re.sub(r'\[Contents\]\s*\[Index\]', '', html_text, flags=re.IGNORECASE)
    html_text = re.sub(r'\s*<a class="copiable-link"[^>]*>.*?</a>\s*', ' ', html_text, flags=re.DOTALL | re.IGNORECASE)
    return html_text

def deident_code(code_lines):
    if not code_lines:
        return ""
    lines = code_lines.split("\n")
    min_indent = -1
    for line in lines:
        if line.strip():
            indent = len(line) - len(line.lstrip())
            if min_indent == -1 or indent < min_indent:
                min_indent = indent
    if min_indent <= 0:
        return code_lines
    dedented_lines = []
    for line in lines:
        if len(line) >= min_indent:
            dedented_lines.append(line[min_indent:])
        else:
            dedented_lines.append(line)
    return "\n".join(dedented_lines)

def load_markdown_docs(docs_dir):
    docs = []
    if not os.path.exists(docs_dir):
        return docs
    for filename in sorted(os.listdir(docs_dir)):
        filepath = os.path.join(docs_dir, filename)
        if filename.endswith(".md"):
            name = filename[:-3]
            with open(filepath, "r", encoding="utf-8") as f:
                docs.append({"name": name, "format": "md", "html": f.read()})
        elif filename.endswith(".html"):
            name = filename[:-5]
            with open(filepath, "r", encoding="utf-8") as f:
                html = _extract_body_html(f.read())
                html = _refine_info_html(html)
                docs.append({"name": name, "format": "html", "html": html})
    return docs

def sanitize_id(name):
    return re.sub(r"[^a-zA-Z0-9_]", "_", name)

def extract_docstring(body_text):
    doc_pattern = re.compile(r'^\s*("([^"\\]*(\\.[^"\\]*)*)"|\'([^\'\\]*(\\.[^\'\\]*)*)\')', re.MULTILINE)
    match = doc_pattern.search(body_text)
    if match:
        doc = (match.group(2) or match.group(4) or "").strip()
        remaining = body_text[match.end():]
        return doc, remaining
    return "", body_text

def parse_function_body(chunk, start_pos):
    depth = 0
    in_string = False
    in_comment = False
    string_char = None
    escape_next = False
    body_start = -1
    i = start_pos
    while i < len(chunk):
        char = chunk[i]
        if escape_next:
            escape_next = False
            i += 1
            continue
        if char == "\\" and in_string:
            escape_next = True
            i += 1
            continue
        if char == ";" and not in_string:
            in_comment = True
            i += 1
            continue
        if char == "\n" and in_comment:
            in_comment = False
            i += 1
            continue
        if in_comment:
            i += 1
            continue
        if char in ('"', "'") and not in_string:
            in_string = True
            string_char = char
            i += 1
            continue
        if char == string_char and in_string:
            in_string = False
            string_char = None
            i += 1
            continue
        if in_string:
            i += 1
            continue
        if char == "{":
            if depth == 0:
                body_start = i
            depth += 1
        elif char == "}":
            depth -= 1
            if depth == 0 and body_start != -1:
                return chunk[body_start + 1:i], i + 1
        i += 1
    return None, start_pos

def parse_imports(body_text):
    imports = []
    import_pattern = re.compile(r"use\s+([a-zA-Z0-9_.]+)(?:\s+as\s+([a-zA-Z0-9_]+))?")
    for match in import_pattern.finditer(body_text):
        full_path = match.group(1)
        alias = match.group(2)
        parts = full_path.split(".")
        if len(parts) > 1:
            module_target = ".".join(parts[:-1])
            symbol_target = parts[-1]
        else:
            module_target = ""
            symbol_target = full_path
        imports.append({"full_path": full_path, "module_target": module_target, "symbol_target": symbol_target, "alias": alias})
    return imports

def clean_code_view(code_lines):
    if not code_lines:
        return ""
    lines = code_lines.split("\n")
    while lines and not lines[0].strip():
        lines.pop(0)
    while lines and not lines[-1].strip():
        lines.pop()
    return "\n".join(lines)

def parse_nytrix_docs(bundle_path, docs_dirs=None):
    if not os.path.exists(bundle_path):
        print(f"Error: Bundle file not found: {bundle_path}", file=sys.stderr)
        return []
    with open(bundle_path, "r", encoding="utf-8") as f:
        content = f.read()

    modules = []
    chunks = re.split(r"(;;\s*Module from\s+.*)", content)
    i = 0
    parsed_count = 0

    while i < len(chunks):
        chunk = chunks[i]
        header = ""
        body = chunk
        if chunk.strip().startswith(";; Module from"):
            header = chunk
            if i + 1 < len(chunks):
                body = chunks[i + 1]
                i += 1
            else:
                body = ""
        elif not chunk.strip():
            i += 1
            continue

        mod_match = re.search(r"module\s+([a-zA-Z0-9.]+)\s*\(", body)
        if not mod_match:
            i += 1
            continue

        mod_name = mod_match.group(1)
        path = mod_name.split(".")

        orig_file = ""
        if header:
            file_match = re.search(r";;\s*Module from\s+([a-zA-Z0-9_/.]+)\.ny", header)
            if file_match:
                orig_file = file_match.group(1) + ".ny"

        mod_doc = ""
        mod_doc_match = re.search(
            r"module\s+[\w\.]+\s*\([^)]*\)\s*\{\s*(\"([^\"\\]*(\\.[^\"\\]*)*)\"|\'([^\'\\]*(\\.[^\'\\]*)*)\')",
            body,
            re.DOTALL,
        )
        if mod_doc_match:
            mod_doc = (mod_doc_match.group(2) or mod_doc_match.group(4) or "").strip()

        symbols = []
        fn_pattern = re.compile(r"fn\s+([a-zA-Z0-9_.:]+)\s*\((.*?)\)\s*\{", re.DOTALL)
        for fn_match in fn_pattern.finditer(body):
            fn_name = fn_match.group(1)
            fn_args = fn_match.group(2).strip()
            full_name = fn_name + (f"({fn_args})" if fn_args else "")
            fn_body, _ = parse_function_body(body, fn_match.end() - 1)
            if fn_body is None:
                continue
            doc, code_view = extract_docstring(fn_body)
            code_view = deident_code(code_view)
            code_view = clean_code_view(code_view)
            imports = parse_imports(fn_body)
            symbols.append({"id": sanitize_id(full_name), "name": full_name, "kind": "function", "doc": doc, "code": code_view, "imports": imports})

        const_pattern = re.compile(r"def\s+define\s+([a-zA-Z0-9_]+)\s*=", re.MULTILINE)
        for const_match in const_pattern.finditer(body):
            const_name = const_match.group(1)
            symbols.append({"id": sanitize_id(const_name), "name": const_name, "kind": "constant", "sig": f"def {const_name}", "doc": "Constant definition.", "code": const_match.group(0).strip()})

        modules.append({"name": mod_name, "module_doc": mod_doc, "symbols": symbols, "path": path, "orig_file": orig_file})
        parsed_count += 1
        i += 1

    if not docs_dirs:
        docs_dirs = [os.path.join(script_dir, "..", "..", "docs")]
    markdown_docs = []
    seen = set()
    for docs_dir in docs_dirs:
        for doc in load_markdown_docs(docs_dir):
            if doc["name"] in seen:
                continue
            markdown_docs.append(doc)
            seen.add(doc["name"])
    overview_module = {
        "name": "Overview",
        "module_doc": "Nytrix Standard Library - Comprehensive documentation for all modules and functions.",
        "symbols": [],
        "path": ["Home"],
        "markdown_docs": markdown_docs,
    }
    modules.insert(0, overview_module)
    print(f"✓ Parsed {parsed_count} modules with {sum(len(m.get('symbols', [])) for m in modules)} total symbols")
    return modules

class CustomHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
        if self.path == "/":
            self.path = "/index.html"
        return SimpleHTTPRequestHandler.do_GET(self)

    def log_message(self, format, *args):
        pass

def main():
    parser = argparse.ArgumentParser(
        description="Nytrix Documentation Generator",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s build/std_bundle.ny -o build/docs
  %(prog)s build/std_bundle.ny --serve
  %(prog)s --check-docs
        """,
    )
    parser.add_argument("input", nargs="?", help="Path to std_bundle.ny")
    parser.add_argument("-o", "--output", help="Output directory for documentation")
    parser.add_argument("-s", "--serve", action="store_true", help="Serve documentation on local HTTP server")
    parser.add_argument("-p", "--port", type=int, default=8000, help="Port for HTTP server (default: 8000)")
    parser.add_argument("--check-docs", action="store_true", help="Check for missing docstrings")
    args = parser.parse_args()

    if not args.check_docs and not args.input:
        parser.error("input file required (unless using --check-docs)")
    if args.input and not os.path.exists(args.input):
        print(f"Error: Input file not found: {args.input}", file=sys.stderr)
        sys.exit(1)

    if args.input:
        print(f"   Source: {args.input}")
        docs_dirs = [os.path.join(script_dir, "..", "..", "docs")]
        extra_dir = os.getenv("NYTRIX_WEBDOC_INFO_DIR", "/tmp/nytrix-info")
        if os.path.isdir(extra_dir):
            docs_dirs.append(extra_dir)
        data = parse_nytrix_docs(args.input, docs_dirs=docs_dirs)
        if args.output:
            output_dir = Path(args.output)
            output_dir.mkdir(parents=True, exist_ok=True)
            html_path = output_dir / "index.html"
            final_html = HTML_TEMPLATE.replace("DATA_PLACEHOLDER", json.dumps(data, indent=2))
            final_html = final_html.replace("SCRIPT_PLACEHOLDER", JS_SCRIPT_TEMPLATE)
            with open(html_path, "w", encoding="utf-8") as f:
                f.write(final_html)
            print(f"✓ Documentation written to: {html_path}")
        if args.serve:
            serve_dir = args.output if args.output else os.path.dirname(args.input)
            os.chdir(serve_dir)
            print(f"\nServing documentation at http://localhost:{args.port}")
            print("   Press Ctrl+C to stop\n")
            try:
                with socketserver.TCPServer(("", args.port), CustomHandler) as httpd:
                    httpd.serve_forever()
            except KeyboardInterrupt:
                print("\n✓ Server stopped")
            except OSError:
                print(f"Error: Port {args.port} already in use", file=sys.stderr)
                sys.exit(1)

if __name__ == "__main__":
    main()
