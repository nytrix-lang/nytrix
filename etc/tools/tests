#!/usr/bin/env python3
"""
Nytrix Test Orchestrator
"""
import os, sys, time, glob, re, argparse, pty, select, subprocess, signal, hashlib
from concurrent.futures import ProcessPoolExecutor, as_completed

# Colors & Formatting
RESET, GRAY, RED, GREEN, CYAN, YELLOW, BOLD, MAGENTA = "\033[0m", "\033[90m", "\033[31m", "\033[32m", "\033[36m", "\033[33m", "\033[1m", "\033[35m"

def strip_ansi(s): return re.sub(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])', '', s)

def find_ny_bin(preferred="build/ny"):
    for p in (preferred + "_debug", preferred, "./build/ny_debug", "./build/ny", "ny"):
        if os.path.exists(p): return os.path.abspath(p)
    raise FileNotFoundError("Nytrix binary not found")

def run_proc(cmd, input_str=None, cwd=None, env=None, timeout=30):
    start = time.time()
    run_env = env or os.environ.copy()
    if "NY_TEST_PRELOAD" in run_env: run_env["LD_PRELOAD"] = run_env["NY_TEST_PRELOAD"]
    try:
        res = subprocess.run(cmd, input=input_str, capture_output=True, text=True, timeout=timeout, env=run_env, cwd=cwd)
        return {"passed": res.returncode == 0, "duration": time.time() - start, "stdout": res.stdout, "stderr": res.stderr, "code": res.returncode}
    except Exception as e:
        return {"passed": False, "duration": 0, "error": str(e), "code": -1}

class ReplSession:
    def __init__(self, bin_path):
        self.pid, self.fd = pty.fork()
        if self.pid == 0:
            env = os.environ.copy()
            env.update({"ASAN_OPTIONS": "detect_leaks=0", "TERM": "xterm-256color"})
            os.execvpe(bin_path, [bin_path, "-i"], env)
    def read_until(self, rx, timeout=5):
        buf, end = "", time.time() + timeout
        while time.time() < end:
            if self.fd in select.select([self.fd], [], [], 0.1)[0]:
                try:
                    data = os.read(self.fd, 8192).decode(errors="ignore")
                    if not data: break
                    buf += data
                except OSError: break
                if re.search(rx, strip_ansi(buf)): return buf
        raise TimeoutError(f"Timeout waiting for {rx}")
    def send(self, s): os.write(self.fd, (s + "\n").encode())
    def close(self):
        for s in (signal.SIGTERM, signal.SIGKILL):
            try: os.kill(self.pid, s); break
            except OSError: pass
        try: os.close(self.fd)
        except: pass

def shorten(path):
    p = path.replace("etc/tests/", "").replace("test/", "")
    return (p[:20] + "..." + p[-27:]) if len(p) > 50 else p

def run_test(path, bin_path, do_repl):
    # 1. JIT/AOT Run
    aot = run_proc([bin_path, path])
    # 2. REPL Run
    repl = None
    if do_repl:
        repl = run_proc([bin_path, "-i"], input_str=open(path).read(), cwd=os.path.dirname(path))
    # 3. ELF Compile & Run
    elf_fn = f"/tmp/ny_bin_{hashlib.md5(path.encode()).hexdigest()[:8]}"
    if os.path.exists(elf_fn): os.remove(elf_fn)
    comp = run_proc([bin_path, path, "-o", elf_fn])
    if comp["passed"] and os.path.exists(elf_fn):
        run = run_proc([elf_fn], cwd=os.path.dirname(path))
        os.remove(elf_fn)
        elf = {"passed": run["passed"], "duration": comp["duration"] + run["duration"], "stdout": run.get("stdout",""), "stderr": run.get("stderr",""), "code": run.get("code")}
    else:
        elf = {"passed": False, "duration": comp["duration"], "stdout": comp.get("stdout",""), "stderr": comp.get("stderr",""), "code": comp.get("code")}
        
    return path, aot, repl, elf

def print_res(path, aot, repl, elf, idx, total):
    m_aot = f"{GREEN}✓{RESET}" if aot["passed"] else f"{RED}✗{RESET}"
    m_rep = f"{GREEN}✓{RESET}" if (not repl or repl["passed"]) else f"{RED}✗{RESET}"
    m_elf = f"{GREEN}✓{RESET}" if elf["passed"] else f"{RED}✗{RESET}"
    
    dur = int(aot['duration']*1000)
    status = f"[{m_aot}/{m_rep}/{m_elf}] {GRAY}{dur:>4}ms{RESET}"
    print(f"{GRAY}{idx*100//total:>3}%{RESET} {status} {shorten(path)}")
    
    if not aot["passed"]: print(f"{RED}AOT FAIL{RESET} (code {aot.get('code','?')}) {path}: {aot.get('stdout','')}{aot.get('stderr','')}")
    if repl and not repl["passed"]: print(f"{RED}REPL FAIL{RESET} (code {repl.get('code','?')}) {path}: {repl.get('stdout','')}{repl.get('stderr','')}")
    if not elf["passed"]: print(f"{RED}ELF FAIL{RESET} (code {elf.get('code','?')}) {path}: {elf.get('stdout','')}{elf.get('stderr','')}")
    
    return aot["passed"] and (not repl or repl["passed"]) and elf["passed"]

def run_smoke(bin_path):
    RX = r'ny(!)?\s*>'
    repl = ReplSession(bin_path)
    try:
        def interact(cmd, expected_rx):
            print(f"{CYAN}ny>{RESET} {cmd}")
            repl.send(cmd)
            res = ""
            while True:
                res += repl.read_until(RX)
                if len(re.findall(RX, strip_ansi(res))) < 2: continue
                break
            
            for l in strip_ansi(res).splitlines():
                l = l.strip()
                if not l or any(l.startswith(p) for p in ["ny>", "ny!>"]) or cmd in l: continue
                print(f"  {GRAY}↳{RESET} {l}")

        repl.read_until(RX)
        interact("1 + 1", r'2')
        interact("def x = 123", RX)
        interact("x * 2", r'246')
        interact("str_len('hello')", r'5')
        interact("[1, 2, 3].len()", r'3')
    finally: repl.close()
    return True

def main():
    p = argparse.ArgumentParser(); p.add_argument("--bin", default="build/ny"); p.add_argument("--jobs", type=int, default=0); p.add_argument("--pattern"); p.add_argument("--no-smoke", action="store_true")
    args = p.parse_args(); bin_path = find_ny_bin(args.bin)
    dbin = bin_path + "_debug" if "_debug" not in bin_path and os.path.exists(bin_path + "_debug") else bin_path
    jobs = args.jobs or os.cpu_count() or 1
    
    WIDTH = 65
    suites = [("Bench", "etc/tests/bench/*.ny", bin_path, True), ("Runtime", "etc/tests/runtime/**/*.ny", dbin, True), ("Std", "etc/tests/std/**/*.ny", dbin, True)]
    
    total_passed, total_count, timings = 0, 0, []
    start = time.time()
    if not args.no_smoke and not args.pattern:
        name = "Repl"
        side = (WIDTH - len(name) - 6) // 2
        print(f"{GRAY}{'-'*side} [ {CYAN}{name}{RESET}{GRAY} ] {'-'*(WIDTH - side - len(name) - 6)}{RESET}")
        run_smoke(bin_path)

    for name, pattern, b, repl_mode in suites:
        files = sorted([f for f in glob.glob(pattern, recursive=True) if not args.pattern or re.search(args.pattern, f)])
        if not files: continue
        side = (WIDTH - len(name) - 6) // 2
        print(f"{GRAY}{'-'*side} [ {CYAN}{name}{RESET}{GRAY} ] {'-'*(WIDTH - side - len(name) - 6)}{RESET}")
        with ProcessPoolExecutor(max_workers=jobs) as ex:
            futs = [ex.submit(run_test, f, b, repl_mode) for f in files]
            for i, fut in enumerate(as_completed(futs), 1):
                path, aot, rep, elf = fut.result()
                if print_res(path, aot, rep, elf, i, len(files)): total_passed += 1
                total_count += 1; timings.append((path, aot["duration"]))
    
    print(f"{GRAY}{'-'*WIDTH}{RESET}\nTotal: {total_count} | {GREEN if total_passed==total_count else RED}{total_passed} passed{RESET} | {total_count-total_passed} failed in {int((time.time()-start)*1000)}ms")
    if total_passed != total_count: sys.exit(1)

if __name__ == "__main__":
    try: main()
    except KeyboardInterrupt: sys.exit(1)
